// Copyright (c) 2016-2021 Association of Universities for Research in Astronomy, Inc. (AURA)
// For license information see LICENSE or https://opensource.org/licenses/BSD-3-Clause

package clue.gen

import scalafix.v1._
import scala.meta._
import cats.syntax.all._
import metaconfig.Configured
import cats.effect.IO
import edu.gemini.grackle.QueryParser

class GraphQLGen(config: GraphQLGenConfig)
    extends SemanticRule("GraphQLGen")
    with SchemaGen
    with QueryGen {
  def this() = this(GraphQLGenConfig())

  private val Guard: String      = "Generated by clue."
  private val StartGuard: String = s"BEGIN: $Guard"
  private val EndGuard: String   = s"END: $Guard"

  private val StartComment: String =
    s"/* $StartGuard DO NOT remove or edit the following code or this comment. */"
  private val EndComment: String   =
    s"/* $EndGuard Will be replaced when regenerating. */"

  private val FormatOff: String = "// format: off"
  private val FormatOn: String  = "// format: on"

  override def withConfiguration(config: Configuration): Configured[Rule] =
    config.conf
      .getOrElse("GraphQLGen")(this.config)
      .map(newConfig => new GraphQLGen(newConfig))

  private def indented(asTree: Tree)(lines: String): String = {
    val indentCols    = asTree.pos match {
      case range: Position.Range => range.startColumn
      case _                     => 0
    }
    val newLineIndent = "\n" + " " * indentCols
    newLineIndent + lines.replaceAll("\\n", newLineIndent)
  }

  override def fix(implicit doc: SemanticDocument): Patch = {
    val removePatch: List[IO[Patch]] =
      doc.tokens.collect {
        case start @ Token.Comment(value) if value.contains(StartGuard) =>
          IO {
            val tokenList = doc.tokenList
            tokenList
              .find(start) {
                case Token.Comment(value) if value.contains(EndGuard) => true
                case _                                                => false
              }
              .fold(Patch.empty) { end =>
                // The previous token to the start comment should be the newline we insert.
                // Start comment may be indented. Leading spaces are reversed, so we focus on last.
                // Similarly, the next token to the end comment is a newline.
                Patch.removeTokens(
                  tokenList.slice(
                    tokenList.prev(tokenList.leadingSpaces(start).lastOption.getOrElse(start)),
                    tokenList.next(tokenList.next(end))
                  )
                )
              }
          }
      }.toList

    val genPatch: List[IO[Patch]] =
      doc.tree
        .collect {
          case obj @ Defn.Object(
                mods @ GraphQLSchemaAnnotation(_),
                templateName,
                // Nil,
                // _,
                Template(early, inits, self, stats)
              ) if templateName.value.endsWith("GQL") =>
            val objName = templateName.value.stripSuffix("GQL")
            config.getSchema(objName).map { schema =>
              val modObjDefs = scala.Function.chain(
                List(addScalars, addEnums(schema, config), addInputs(schema, config))
              )

              // Can't get RemoveUnused to remove the unused import, since rules in the same run are note applied incrementally.
              // See https://github.com/scalacenter/scalafix/issues/1204
              val newMods = GraphQLSchemaAnnotation.removeFrom(mods)

              Patch.addRight(
                obj,
                "\n" +
                  indented(obj)(
                    List(
                      StartComment,
                      FormatOff,
                      q"sealed trait ${Type.Name(objName)}".toString,
                      q"..$newMods object ${Term
                        .Name(objName)} extends {..$early} with ..$inits { $self => ..${modObjDefs(stats)} }".toString,
                      FormatOn,
                      EndComment
                    ).mkString("\n")
                  )
              )
            }
          // TODO Remove annotation, which implies remove import, which is not that simple (it could come from a wildcard).
          // There's a RemoveUnused rule, maybe we can reuse part of its logic?
          // case importee @ Importee.Name(Name(GraphQLSchemaAnnotation.name))      =>
          //   Patch.removeImportee(importee)
          // case importee @ Importee.Rename(Name(GraphQLSchemaAnnotation.name), _) =>
          //   Patch.removeImportee(importee)
          case obj @ Defn.Trait(
                mods @ GraphQLAnnotation(_),
                templateName,
                Nil,
                _,
                Template(early, inits, self, stats)
              ) if templateName.value.endsWith("GQL") =>
            val objName = templateName.value.stripSuffix("GQL")

            extractSchemaType(inits) match {
              case None             =>
                abort(
                  "Invalid annotation target: must be an object extending GraphQLOperation[Schema]"
                )
              case Some(schemaType) =>
                extractDocument(stats) match {
                  case None           =>
                    abort(
                      "The GraphQLOperation must define a 'val document: String' with a literal value."
                    )
                  case Some(document) =>
                    config.getSchema(schemaType.value).flatMap { schema =>
                      // Parse the operation.
                      val queryResult = QueryParser.parseText(document)
                      if (queryResult.isLeft)
                        abort(
                          s"Could not parse document: ${queryResult.left.get.toChain.map(_.toString).toList.mkString("\n")}"
                        )
                      else {
                        IO.whenA(queryResult.isBoth)(
                          log(
                            s"Warning parsing document: ${queryResult.left.get.toChain.map(_.toString).toList.mkString("\n")}"
                          )
                        ) >> IO {
                          val operation = queryResult.toOption.get

                          // Modifications to add the missing definitions.
                          val modObjDefs = scala.Function.chain(
                            List(
                              addImports(schemaType.value),
                              addVars(schema, operation, config),
                              addData(schema, operation, config),
                              addVarEncoder,
                              addDataDecoder,
                              addConvenienceMethod(schemaType, operation)
                            )
                          )

                          val newMods = GraphQLAnnotation.removeFrom(mods)

                          // Congratulations! You got a full-fledged GraphQLOperation (hopefully).
                          Patch.addRight(
                            obj,
                            "\n" +
                              indented(obj)(
                                List(
                                  StartComment,
                                  FormatOff,
                                  q"..$newMods object ${Term
                                    .Name(objName)} extends {..$early} with ..$inits { $self => ..${modObjDefs(stats)} }".toString,
                                  FormatOn,
                                  EndComment
                                ).mkString("\n")
                              )
                          )
                        }
                      }
                    }
                }
            }
        }

    (removePatch ++ genPatch).sequence
      .unsafeRunSync()
      .asPatch
  }

}
